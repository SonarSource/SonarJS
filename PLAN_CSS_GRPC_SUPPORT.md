# Plan: Add CSS Analysis Support to gRPC Server

## Problem

The gRPC server (`packages/grpc`) currently only supports JavaScript and TypeScript analysis. CSS files sent to A3S are received by the JSTS analyzer but produce zero issues because:

1. `transformActiveRule` in `packages/grpc/src/transformers/request.ts:346` rejects any rule with repository other than `javascript` or `typescript`
2. `analyzeProject()` in `packages/jsts/src/analysis/projectAnalysis/analyzeProject.ts` only routes files to JS/TS analyzers — it never calls `analyzeCSS()` from `packages/css/src/analysis/analyzer.ts`

CSS analysis in SonarJS uses **stylelint** (not ESLint), with a completely separate code path.

## Background: How CSS Analysis Works in the Bridge (SonarQube Plugin)

In the SonarQube bridge (`packages/bridge/src/handle-request.ts`):

- The Java plugin sends an `on-analyze-css` request with:
  - `filePath`, `fileContent` (same as gRPC)
  - `rules`: array of `{ key: string, configurations: any[] }` where `key` is the **stylelint rule key** (e.g. `"font-family-no-duplicate-names"`)
- The bridge calls `analyzeCSS(input, ...)` from `packages/css/src/analysis/analyzer.ts`
- `analyzeCSS` creates a stylelint config via `createStylelintConfig(rules)` and lints the file

**Key difference**: Today, the Java plugin translates SonarQube rule keys (e.g. `css:S4648`) to stylelint keys (e.g. `font-family-no-duplicate-names`) before sending to the bridge. Each CSS rule has a manually-written Java class with a `stylelintKey()` method.

## Background: How CSS Rules Arrive via gRPC (A3S)

In A3S, the Hub fetches active rules from the quality profile and sends them to the JSTS analyzer via gRPC. CSS rules arrive with:

- `ruleKey.repo = "css"`
- `ruleKey.rule = "S4648"` (the SonarQube key, NOT the stylelint key)

The gRPC server needs to:

1. Accept `css` repository rules
2. Map SonarQube CSS rule keys (S4648) to stylelint keys (font-family-no-duplicate-names)
3. Route CSS files to `analyzeCSS()` inside `analyzeProject()`

## Note on CSS files in the gRPC file store

In the gRPC flow, `canAccessFileSystem = false`, so `SourceFileStore.isInitialized` short-circuits and stores `inputFiles` directly (bypassing the `isAnalyzableFile` filter that would normally exclude CSS files). This means **CSS files are already present in `sourceFileStore.getFiles()`** in the gRPC path. However, they currently fall through as "not part of any tsconfig" and get processed (silently or with noise) by the JS/TS analyzers. The fix is to separate them in `analyzeProject()` before the JS/TS analysis loop.

---

## Part 1: CSS Rule Metadata System (Single Source of Truth)

This is a prerequisite for the gRPC support. The motivation is to mirror the existing JS/TS pipeline:

|                      | JS/TS                                             | CSS (today)                     | CSS (target)                                          |
| -------------------- | ------------------------------------------------- | ------------------------------- | ----------------------------------------------------- |
| Rule metadata        | `config.ts` per rule + RSPEC JSON                 | Only in Java (manually written) | `packages/css/src/rules/metadata.ts`                  |
| Java classes         | Auto-generated by `generate-java-rule-classes.ts` | Manually written                | Auto-generated by `generate-css-java-rule-classes.ts` |
| Java classes in git  | ❌ (gitignored)                                   | ✅ (committed)                  | ❌ (gitignored)                                       |
| SQ→stylelint key map | N/A (keys match)                                  | Only in Java                    | Exported from `metadata.ts`                           |

### 1a. CSS Rule Metadata File

Create `packages/css/src/rules/metadata.ts` as the single source of truth for all 29 CSS rules.

#### Analogues to JS/TS `config.ts` escape hatches

In JS/TS, `ESLintConfigurationSQProperty` has two escape hatches used in exactly 4 rules total:

- `customDefault`: when `@RuleProperty defaultValue` in Java differs from the ESLint default (e.g. different regex escaping for Java string literals vs JS)
- `customForConfiguration`: a **Java expression string** that replaces the field variable in `configurations()` (e.g. `'value ? "single" : "double"'` for S1441, `'Double.parseDouble(randomnessSensibility)'` for S6418)

Note that `customForConfiguration` is always a **short expression** — never a full method body. The generator wraps it inside the `configurations()` return statement.

For CSS, looking at all 8 parameterized rules, **no raw Java string escape hatches are needed** — all cases can be handled declaratively with two param types:

#### Type design

```typescript
// String-list ignore param — covers 7/8 parameterized rules
// Produces a @RuleProperty String field and contributes to [true, { key: splitAndTrim(field) }]
export type StylelintIgnoreParam = {
  sqKey: string; // SonarQube @RuleProperty key (e.g. 'ignoreAtRules')
  javaField: string; // Java field name (e.g. 'ignoredAtRules')
  description: string; // SonarQube UI description
  default: string; // Default comma-separated value (empty string = no default)
  stylelintOptionKey: string; // Key in the stylelint options object (e.g. 'ignoreAtRules')
};

// Boolean param that conditionally enables fixed stylelint options — covers S4656 only
// Produces a @RuleProperty boolean field and a conditional stylelintOptions()
export type StylelintBooleanParam = {
  sqKey: string; // SonarQube @RuleProperty key
  javaField: string; // Java field name
  description: string;
  default: boolean;
  // When field is true, emit [true, { key: values }]; when false, emit []
  onTrue: Array<{ stylelintOptionKey: string; values: string[] }>;
};

export type CssRuleMeta = {
  sqKey: string; // SonarQube rule key (e.g. 'S4648')
  stylelintKey: string; // Stylelint rule key (e.g. 'font-family-no-duplicate-names')
  className: string; // Java class name (e.g. 'FontFamilyNoDuplicateNames')
  // String-list ignore params — generator produces [true, { key: splitAndTrim(field), ... }]
  ignoreParams?: StylelintIgnoreParam[];
  // Boolean param with conditional fixed options — only S4656 uses this
  booleanParam?: StylelintBooleanParam;
};
```

No raw Java strings. The `booleanParam.onTrue` declaratively describes what to emit, and the generator produces the inner class and conditional return.

**How `ignoreParams` generates Java** (7 rules):

```java
// From ignoreParams[0]: { javaField:'ignoredAtRules', sqKey:'ignoreAtRules', default:'...', stylelintOptionKey:'ignoreAtRules' }
private static final String DEFAULT_IGNORED_AT_RULES = "value,at-root,...";

@RuleProperty(key = "ignoreAtRules", description = "...", defaultValue = DEFAULT_IGNORED_AT_RULES)
String ignoredAtRules = DEFAULT_IGNORED_AT_RULES;

@Override
public List<Object> stylelintOptions() {
  return Arrays.asList(true, new StylelintIgnoreOption(splitAndTrim(ignoredAtRules)));
}

private static class StylelintIgnoreOption {

  private final List<String> ignoreAtRules; // from stylelintOptionKey

  StylelintIgnoreOption(List<String> ignoreAtRules) {
    this.ignoreAtRules = ignoreAtRules;
  }
}
```

**How `booleanParam` generates Java** (S4656 only):

```java
// From booleanParam: { javaField:'ignoreFallbacks', default:true, onTrue:[{stylelintOptionKey:'ignore', values:['consecutive-duplicates-with-different-values']}] }
@RuleProperty(key = "ignoreFallbacks", description = "...", defaultValue = "" + true)
boolean ignoreFallbacks = true;

@Override
public List<Object> stylelintOptions() {
  return ignoreFallbacks
    ? Arrays.asList(true, new StylelintIgnoreOption())
    : Collections.emptyList();
}

private static class StylelintIgnoreOption {

  private final List<String> ignore = Collections.singletonList(
    "consecutive-duplicates-with-different-values"
  );
}
```

**Example entries:**

```typescript
export const cssRulesMeta: CssRuleMeta[] = [
  // No params
  {
    sqKey: 'S4648',
    stylelintKey: 'font-family-no-duplicate-names',
    className: 'FontFamilyNoDuplicateNames',
  },

  // Single string-list ignore param
  {
    sqKey: 'S4662',
    stylelintKey: 'at-rule-no-unknown',
    className: 'AtRuleNoUnknown',
    ignoreParams: [
      {
        sqKey: 'ignoreAtRules',
        javaField: 'ignoredAtRules',
        description: 'Comma-separated list of at-rules to consider as valid.',
        default: 'value,at-root,content,...',
        stylelintOptionKey: 'ignoreAtRules',
      },
    ],
  },

  // Two string-list ignore params
  {
    sqKey: 'S4654',
    stylelintKey: 'property-no-unknown',
    className: 'PropertyNoUnknown',
    ignoreParams: [
      {
        sqKey: 'ignoreTypes',
        javaField: 'ignoreProperties',
        description: '...',
        default: 'composes, /^mso-/',
        stylelintOptionKey: 'ignoreProperties',
      },
      {
        sqKey: 'ignoreSelectors',
        javaField: 'ignoreSelectors',
        description: '...',
        default: '/^:export.*/, /^:import.*/',
        stylelintOptionKey: 'ignoreSelectors',
      },
    ],
  },

  // Boolean conditional (the only rule of this kind)
  {
    sqKey: 'S4656',
    stylelintKey: 'declaration-block-no-duplicate-properties',
    className: 'DeclarationBlockNoDuplicateProperties',
    booleanParam: {
      sqKey: 'ignoreFallbacks',
      javaField: 'ignoreFallbacks',
      description: 'Ignore consecutive duplicated properties with different values.',
      default: true,
      onTrue: [
        { stylelintOptionKey: 'ignore', values: ['consecutive-duplicates-with-different-values'] },
      ],
    },
  },

  // Custom SonarJS stylelint plugin (sonar/* prefix)
  { sqKey: 'S125', stylelintKey: 'sonar/no-commented-code', className: 'NoCommentedCode' },
];
```

**Exports for consumers:**

```typescript
// Used by the gRPC transformer — no hand-coded mapping needed
export const cssRuleKeyMap = new Map(cssRulesMeta.map(r => [r.sqKey, r.stylelintKey]));
export const reverseCssRuleKeyMap = new Map(cssRulesMeta.map(r => [r.stylelintKey, r.sqKey]));
```

### 1b. Java Generator Script

**Extend** `tools/generate-java-rule-classes.ts` — no new script needed. Both JS/TS and CSS Java class generation use the same shared helpers (`inflateTemplateToFile`, `writePrettyFile`, `header`) and are run in the same situations. Adding CSS at the end of the existing script keeps everything in one place.

Add to the bottom of `generate-java-rule-classes.ts`:

```typescript
// --- CSS rule classes ---
import { cssRulesMeta } from '../packages/css/src/rules/metadata.js';

const CSS_JAVA_CHECKS_FOLDER = join(
  'sonar-plugin',
  'css',
  'src',
  'main',
  'java',
  'org',
  'sonar',
  'css',
  'rules',
);

for (const rule of cssRulesMeta) {
  await generateCssJavaCheckClass(rule);
}

await inflateTemplateToFile(
  join(JAVA_TEMPLATES_FOLDER, 'css-rules.template'),
  join(CSS_JAVA_CHECKS_FOLDER, '..', 'CssRules.java'),
  {
    ___HEADER___: header,
    ___CSS_RULE_CLASSES___: cssRulesMeta
      .toSorted(sonarKeySorter)
      .map(r => `${r.className}.class`)
      .join(','),
  },
);
```

**New template** (`tools/templates/java/css-check.template`):

```java
___HEADER___
package org.sonar.css.rules;
___IMPORTS___

@Rule(key = "___RULE_KEY___")
public class ___CLASS_NAME___ implements CssRule {
___BODY___
  @Override
  public String stylelintKey() {
    return "___STYLELINT_KEY___";
  }
}
```

The `___BODY___` section is computed by a new `generateCssBody()` function from `ignoreParams` or `booleanParam`.

### 1c. Auto-generated `CssRuleTest.java`

The existing `CssRuleTest.java` is **entirely derivable from `metadata.ts`** and should be generated alongside the implementation classes. Every assertion in it maps directly to metadata fields:

| Test                                      | Derived from                                                                                    |
| ----------------------------------------- | ----------------------------------------------------------------------------------------------- |
| `class_name_should_match_stylelint_key()` | Generic reflection loop — unchanged, always valid                                               |
| `rules_default_is_empty()`                | Set of `className` where `ignoreParams` or `booleanParam` is present                            |
| `rules_properties_count()`                | Count of `ignoreParams` entries + `booleanParam` entries across all rules                       |
| Per-rule default GSON test                | `ignoreParams[i].default` split by comma → `[true, {"optionKey": [...]}]`                       |
| Per-rule custom GSON test                 | Set field to `"testValue1, testValue2"` → `[true, {"optionKey": ["testValue1", "testValue2"]}]` |
| Boolean default test                      | `booleanParam.default=true` → GSON of `onTrue` values                                           |
| Boolean custom test                       | Set field to `false` → empty list                                                               |

For example, from S4662's `ignoreParams[0]`:

```typescript
{ javaField: 'ignoredAtRules', default: 'value,at-root,...', stylelintOptionKey: 'ignoreAtRules' }
```

The generator produces:

```java
@Test
void at_rule_unknown_default() {
  String optionsAsJson = GSON.toJson(new AtRuleNoUnknown().stylelintOptions());
  assertThat(optionsAsJson).isEqualTo("[true,{\"ignoreAtRules\":[\"value\",\"at-root\",...]}]");
}

@Test
void at_rule_unknown_custom() {
  AtRuleNoUnknown instance = new AtRuleNoUnknown();
  instance.ignoredAtRules = "testValue1, testValue2";
  assertThat(GSON.toJson(instance.stylelintOptions())).isEqualTo(
    "[true,{\"ignoreAtRules\":[\"testValue1\",\"testValue2\"]}]"
  );
}
```

`CssRuleTest.java` is gitignored alongside the implementation. `CssRulesDefinitionTest.java` remains manually written — it tests the SonarQube rule repository API (rule names, debt model) which comes from RSPEC JSON, not `metadata.ts`.

### 1d. Build integration and gitignore

No new `package.json` script needed — CSS classes and tests are generated by the existing `generate-java-rule-classes` command.

Add to `.gitignore`:

```gitignore
# Auto-generated CSS Java rule classes
sonar-plugin/css/src/main/java/org/sonar/css/rules/AtRuleNoUnknown.java
sonar-plugin/css/src/main/java/org/sonar/css/rules/BlockNoEmpty.java
# ... (all individual rule classes)
sonar-plugin/css/src/main/java/org/sonar/css/CssRules.java
# NOT gitignored: CssRule.java (interface), RuleUtils.java, package-info.java
```

Or use a glob pattern if gitignore supports it:

```gitignore
sonar-plugin/css/src/main/java/org/sonar/css/rules/[A-Z]*.java
```

(This excludes `package-info.java` since it starts lowercase, and `CssRule.java` / `RuleUtils.java` can be explicitly excluded from the glob by keeping them in a list.)

---

## Part 2: gRPC CSS Analysis Support

With `metadata.ts` in place, the gRPC-specific steps become simpler.

### 2.1 CSS rule transformation in `packages/grpc/src/transformers/request.ts`

The hand-coded `css-rule-metadata.ts` is **not needed** — import `cssRuleKeyMap` from `packages/css/src/rules/metadata.ts` directly.

Modify `transformActiveRule()`:

```typescript
if (repo === 'css') {
  return transformCssActiveRule(ruleKey, activeRule.params || []);
}
if (repo !== 'javascript' && repo !== 'typescript') {
  console.warn(`Ignoring rule ${ruleKey} with unsupported repository '${repo}'.`);
  return [];
}
```

Add `transformCssActiveRule()`:

```typescript
function transformCssActiveRule(sqKey: string, params: analyzer.IRuleParam[]): CssRuleConfig[] {
  const stylelintKey = cssRuleKeyMap.get(sqKey);
  if (!stylelintKey) {
    console.warn(`Unknown CSS rule ${sqKey}`);
    return [];
  }
  // CSS rules rarely have configurable params; configurations come from the Java defaults
  // For gRPC, the SonarQube server sends params already resolved to their configured values
  const configurations = buildCssConfigurations(sqKey, params);
  return [{ key: stylelintKey, configurations }];
}
```

### 2.2 Add `cssRules` to `ProjectAnalysisInput` and `transformRequestToProjectInput`

In `packages/jsts/src/analysis/projectAnalysis/projectAnalysis.ts`:

```typescript
export type ProjectAnalysisInput = {
  rules: RuleConfig[];
  cssRules: CssRuleConfig[]; // NEW: stylelint rules for CSS files
  bundles: NormalizedAbsolutePath[];
  rulesWorkdir?: NormalizedAbsolutePath;
};
```

In `packages/grpc/src/transformers/request.ts`, `transformRequestToProjectInput` collects both JS/TS rules into `rules` and CSS rules into `cssRules`. Returns a single `ProjectAnalysisInput`.

Also add `CssFileResult` to `FileResult` in `projectAnalysis.ts`:

```typescript
// CSS issue — only has ruleId (SQ key after reverse-mapping), line, column, message
export type CssFileResult = {
  cssIssues: Array<{ ruleId: string; line: number; column: number; message: string }>;
};

export type FileResult =
  | JsTsAnalysisOutput
  | JsTsAnalysisOutputWithAst
  | EmbeddedAnalysisOutput
  | CssFileResult // NEW
  | ParsingError
  | { error: string };
```

### 2.3 Modify `analyzeProject()` to route CSS files internally

In `packages/jsts/src/analysis/projectAnalysis/analyzeProject.ts`, before the JS/TS analysis loop:

```typescript
const filesToAnalyze = sourceFileStore.getFiles();

// Separate CSS files — they need stylelint, not ESLint
const cssFiles: [NormalizedAbsolutePath, JsTsFile][] = [];
const pendingFiles = new Set<NormalizedAbsolutePath>();

for (const [filePath, file] of Object.entries(filesToAnalyze) as [
  NormalizedAbsolutePath,
  JsTsFile,
][]) {
  if (isCssFile(filePath, configuration.cssSuffixes)) {
    cssFiles.push([filePath, file]);
    // .vue files also stay in pendingFiles for JS/TS analysis
    if (filePath.endsWith('.vue')) pendingFiles.add(filePath);
  } else {
    pendingFiles.add(filePath);
  }
}

// Analyze CSS files with stylelint
if (cssFiles.length > 0 && input.cssRules.length > 0) {
  const shouldIgnoreParams = getShouldIgnoreParams(configuration);
  for (const [filePath, file] of cssFiles) {
    try {
      const cssOutput = await analyzeCSS(
        { filePath, fileContent: file.fileContent, rules: input.cssRules },
        shouldIgnoreParams,
      );
      // Reverse-map stylelint keys back to SQ keys before storing
      results.files[filePath] = {
        cssIssues: cssOutput.issues.map(issue => ({
          ...issue,
          ruleId: reverseCssRuleKeyMap.get(issue.ruleId) ?? issue.ruleId,
        })),
      } as CssFileResult;
    } catch (err) {
      results.files[filePath] = { error: String(err) };
    }
  }
}

// Continue with JS/TS analysis using pendingFiles (pure CSS files excluded)
```

`reverseCssRuleKeyMap` is imported from `packages/css/src/rules/metadata.ts`.

**`service.ts` is not modified** — it remains a thin handler calling `analyzeProject()` with no CSS-specific logic.

### 2.4 Handle CSS issues in `packages/grpc/src/transformers/response.ts`

```typescript
if ('cssIssues' in fileResult) {
  for (const issue of fileResult.cssIssues) {
    issues.push({
      filePath,
      message: issue.message,
      rule: { repo: 'css', rule: issue.ruleId }, // already mapped to SQ key (e.g. S4648)
      textRange: {
        startLine: issue.line,
        startLineOffset: issue.column,
        endLine: issue.line, // stylelint doesn't provide endLine
        endLineOffset: issue.column,
      },
      flows: [],
    });
  }
  continue;
}
```

### 2.5 Add tests

Add to `packages/grpc/tests/server.test.ts`:

```typescript
it('should analyze CSS file with CSS rules', async () => {
  const request = {
    analysisId: generateAnalysisId(),
    contextIds: {},
    sourceFiles: [{ relativePath: '/project/src/styles.css', content: 'a { font-family: Arial, Arial; }' }],
    activeRules: [{ ruleKey: { repo: 'css', rule: 'S4648' }, params: [] }],
  };
  const response = await client.analyze(request);
  expect(response.issues.length).toBe(1);
  expect(response.issues[0].rule.repo).toBe('css');
  expect(response.issues[0].rule.rule).toBe('S4648');
});

it('should analyze SCSS file', async () => { ... });
it('should analyze Vue file with <style> block', async () => { ... });
it('should handle mixed JS+CSS rules for Vue files', async () => { ... });
it('should pass configurable CSS rule params (S4662 ignoreAtRules)', async () => { ... });
```

---

## Files to Create / Modify

### New files

1. **`packages/css/src/rules/metadata.ts`** — Single source of truth: all 29 CSS rules with SQ key, stylelint key, class name, parameters + exports `cssRuleKeyMap`, `reverseCssRuleKeyMap`
2. **`tools/templates/java/css-check.template`** — Java template for CSS rule classes
3. **`tools/templates/java/css-rules.template`** — Java template for `CssRules.java`
4. **`tools/templates/java/css-rule-test.template`** — Java template for `CssRuleTest.java`

### Modified files

5. **`tools/generate-java-rule-classes.ts`** — Add CSS generation at the end (new `generateCssJavaCheckClass()` + `generateCssBody()` + `generateCssRuleTest()` functions)
6. **`packages/grpc/src/transformers/request.ts`** — Accept `css` repo; import `cssRuleKeyMap` from `packages/css/src/rules/metadata.ts`; add `transformCssActiveRule()`
7. **`packages/jsts/src/analysis/projectAnalysis/projectAnalysis.ts`** — Add `cssRules` to `ProjectAnalysisInput`, add `CssFileResult` to `FileResult`
8. **`packages/jsts/src/analysis/projectAnalysis/analyzeProject.ts`** — Separate CSS files, call `analyzeCSS()` internally
9. **`packages/grpc/src/transformers/response.ts`** — Handle `CssFileResult`
10. **`packages/grpc/tests/server.test.ts`** — CSS tests
11. **`.gitignore`** — Add generated CSS Java files (implementation + test)

### Regenerated (then gitignored)

12. All `sonar-plugin/css/src/main/java/org/sonar/css/rules/<RuleName>.java` — individual rule classes
13. **`sonar-plugin/css/src/main/java/org/sonar/css/CssRules.java`** — rule registry
14. **`sonar-plugin/css/src/test/java/org/sonar/css/rules/CssRuleTest.java`** — parameter option tests

### NOT modified

- ~~`packages/grpc/src/service.ts`~~ — no changes needed
- `sonar-plugin/css/src/main/java/org/sonar/css/rules/CssRule.java` — handwritten interface, not generated
- `sonar-plugin/css/src/main/java/org/sonar/css/rules/RuleUtils.java` — handwritten utility, not generated
- `sonar-plugin/css/src/test/java/org/sonar/css/CssRulesDefinitionTest.java` — tests RSPEC/SQ API, stays manual

---

## Key Dependencies

- `packages/css/src/analysis/analyzer.ts` — `analyzeCSS()` function
- `packages/css/src/linter/config.ts` — `createStylelintConfig()`, `RuleConfig` type
- `packages/shared/src/helpers/configuration.ts` — `isCssFile()`, `DEFAULT_CSS_EXTENSIONS` (`.css`, `.less`, `.scss`, `.sass`)
- `tools/helpers.ts` — `inflateTemplateToFile`, `writePrettyFile`, `header` (reuse for CSS generator)
- `sonar-plugin/css/src/main/resources/org/sonar/l10n/css/rules/css/*.json` — RSPEC metadata for CSS rules (already exists)

---

## Important Notes

- CSS analysis uses stylelint (not ESLint) — completely separate engine
- The SQ→stylelint key mapping moves from Java-only to Node.js `metadata.ts` (source of truth)
- `.vue` files contain both JS/TS and CSS — `analyzeProject()` runs ESLint on the JS part already; `analyzeCSS()` additionally processes `<style>` blocks
- CSS rules have very few configurable parameters — 20/28 have none, 8 have params
- **7 of the 8 parameterized rules** use `ignoreParams` (string → comma-split → `ignoreXxx` list)
- **1 rule** (`S4656`) uses `booleanParam` with `onTrue` — both are fully declarative, no raw Java strings needed
- The JS/TS equivalent escape hatches (`customDefault`, `customForConfiguration`) are NOT needed for CSS — all cases fit the two declarative param types
- CSS Java generation is added to the **existing** `generate-java-rule-classes` script — no new npm script needed; `generate-meta` is not involved (it only generates TypeScript metadata)
- CSS `Issue` type only has `ruleId`, `line`, `column`, `message` (no `endLine`/`endColumn`, no `filePath`, no `language`) — handled in response transformer
- The 5 custom SonarJS CSS rules (S125, S5362, S7923, S7924, S7925) have JS implementations in `packages/css/src/rules/` — their metadata entries in `metadata.ts` just add the Java generation info

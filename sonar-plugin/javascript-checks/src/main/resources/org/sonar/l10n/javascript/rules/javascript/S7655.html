<p>This rule raises an issue when an Angular class defines lifecycle methods without implementing the corresponding lifecycle interfaces.</p>
<h2>Why is this an issue?</h2>
<p>Angular provides lifecycle interfaces like <code>OnInit</code>, <code>OnDestroy</code>, and <code>DoBootstrap</code> that correspond to lifecycle
methods such as <code>ngOnInit()</code>, <code>ngOnDestroy()</code>, and <code>ngDoBootstrap()</code>.</p>
<p>When a class implements lifecycle methods without the corresponding interfaces, several problems arise:</p>
<ul>
  <li> <strong>Type safety is reduced</strong>: TypeScript cannot verify that the method signature matches the expected interface </li>
  <li> <strong>IDE support is limited</strong>: Code completion and refactoring tools work less effectively </li>
  <li> <strong>Code clarity suffers</strong>: Other developers cannot easily see which lifecycle hooks the class uses </li>
  <li> <strong>Angular style guide violations</strong>: The official Angular style guide recommends implementing lifecycle interfaces </li>
</ul>
<p>The Angular compiler and runtime will still work without the interfaces, but the code becomes less maintainable and more error-prone.</p>
<h3>What is the potential impact?</h3>
<p>Without lifecycle interfaces, developers may accidentally implement lifecycle methods with incorrect signatures, leading to runtime issues where
the methods are not called as expected. This can cause initialization logic to fail silently or cleanup code to not execute properly.</p>
<h3>How to fix in Angular?</h3>
<p>Import and implement the corresponding lifecycle interface for each lifecycle method in your class.</p>
<h4>Non-compliant code example</h4>
<pre data-diff-id="1" data-diff-type="noncompliant">
@Component()
class MyComponent {
  ngOnInit() { // Noncompliant
    console.log('Component initialized');
  }

  ngOnDestroy() { // Noncompliant
    console.log('Component destroyed');
  }
}
</pre>
<h4>Compliant code example</h4>
<pre data-diff-id="1" data-diff-type="compliant">
import { OnInit, OnDestroy } from '@angular/core';

@Component()
class MyComponent implements OnInit, OnDestroy {
  ngOnInit() {
    console.log('Component initialized');
  }

  ngOnDestroy() {
    console.log('Component destroyed');
  }
}
</pre>
<p>When extending a base class that already implements the interface, use the <code>override</code> keyword instead of implementing the interface
again.</p>
<h4>Non-compliant code example</h4>
<pre data-diff-id="2" data-diff-type="noncompliant">
@Component()
class BaseComponent implements OnInit {
  ngOnInit() {
    console.log('Base initialization');
  }
}

@Component()
class DerivedComponent extends BaseComponent {
  ngOnInit() { // Noncompliant
    super.ngOnInit();
    console.log('Derived initialization');
  }
}
</pre>
<h4>Compliant code example</h4>
<pre data-diff-id="2" data-diff-type="compliant">
@Component()
class BaseComponent implements OnInit {
  ngOnInit() {
    console.log('Base initialization');
  }
}

@Component()
class DerivedComponent extends BaseComponent {
  override ngOnInit() {
    super.ngOnInit();
    console.log('Derived initialization');
  }
}
</pre>
<h3>Documentation</h3>
<ul>
  <li> Angular Lifecycle Hooks - <a href="https://angular.dev/guide/components/lifecycle">Official Angular documentation on lifecycle hooks and
  interfaces</a> </li>
  <li> Angular Style Guide - Lifecycle Interfaces - <a href="https://angular.dev/style-guide#style-09-01">Angular style guide recommendation for
  implementing lifecycle interfaces</a> </li>
</ul>

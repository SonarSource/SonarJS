<p>This rule raises an issue when built-in constructors are called without the <code>new</code> keyword (except for <code>String</code>,
<code>Number</code>, <code>Boolean</code>, <code>Symbol</code>, and <code>BigInt</code> which should not use <code>new</code>).</p>
<h2>Why is this an issue?</h2>
<p>JavaScript allows calling most built-in constructors both with and without the <code>new</code> keyword, but this inconsistency can lead to
confusion and unexpected behavior.</p>
<p>For most built-in constructors like <code>Array</code>, <code>Object</code>, <code>Date</code>, <code>Map</code>, etc., both <code>Array()</code>
and <code>new Array()</code> work the same way. However, using <code>new</code> makes the intent clearer - you are creating a new instance of an
object. This consistency helps other developers understand your code better.</p>
<p>There are important exceptions: <code>String</code>, <code>Number</code>, <code>Boolean</code>, <code>Symbol</code>, and <code>BigInt</code> should
NOT use <code>new</code>. When called without <code>new</code>, these functions convert values to primitive types. When called with <code>new</code>,
they create wrapper objects instead of primitives, which is rarely what you want and can cause unexpected behavior in comparisons and type checks.</p>
<p>For example, <code>new String('hello')</code> creates a String object, while <code>String('hello')</code> creates a primitive string. The object
version behaves differently in boolean contexts and equality comparisons.</p>
<h3>What is the potential impact?</h3>
<p>Inconsistent constructor usage reduces code readability and maintainability. Using <code>new</code> with primitive wrapper constructors
(<code>String</code>, <code>Number</code>, <code>Boolean</code>) creates wrapper objects that can cause subtle bugs in equality comparisons and type
checks, potentially leading to unexpected application behavior.</p>
<h3>How to fix?</h3>
<p>Add the <code>new</code> keyword when calling built-in constructors (except for primitive wrapper constructors).</p>
<h4>Non-compliant code example</h4>
<pre data-diff-id="1" data-diff-type="noncompliant">
const list = Array(10); // Noncompliant
const now = Date(); // Noncompliant
const map = Map([['foo', 'bar']]); // Noncompliant
</pre>
<h4>Compliant code example</h4>
<pre data-diff-id="1" data-diff-type="compliant">
const list = new Array(10);
const now = new Date();
const map = new Map([['foo', 'bar']]);
</pre>
<h3>Exceptions</h3>
<p>No issue is raised when <code>Object()</code> is called with one or more arguments. Calling <code>Object(value)</code> is a type coercion pattern
that converts the value to an object, preserving existing objects while wrapping primitives. This is semantically different from <code>new
Object()</code> which creates a new empty object, and is a common pattern in polyfills and utility code.</p>
<pre>
const obj = Object(value); // Compliant - type coercion
const wrapped = Object(this); // Compliant - commonly used in polyfills
</pre>
<h3>Documentation</h3>
<ul>
  <li> <a href="https://github.com/sindresorhus/eslint-plugin-unicorn#readme">eslint-plugin-unicorn</a> - Rule <a
  href="https://github.com/sindresorhus/eslint-plugin-unicorn/blob/HEAD/docs/rules/new-for-builtins.md">new-for-builtins</a> </li>
  <li> MDN - new operator - <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/new">Documentation about the new
  operator in JavaScript</a> </li>
  <li> MDN - String constructor - <a
  href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/String">Documentation about String constructor and the
  difference between primitive strings and String objects</a> </li>
  <li> MDN - Primitive vs Object - <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#primitive_values">Explanation of
  primitive values vs objects in JavaScript</a> </li>
</ul>

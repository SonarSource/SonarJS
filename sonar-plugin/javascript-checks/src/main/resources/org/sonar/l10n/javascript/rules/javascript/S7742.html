<p>This rule raises an issue when code imports a polyfill for a feature that is already natively supported by all specified target environments.</p>
<h2>Why is this an issue?</h2>
<p>Polyfills are JavaScript libraries that provide modern functionality to older environments that don’t support it natively. While polyfills are
essential for supporting legacy browsers or older Node.js versions, they become unnecessary overhead when all your target environments already support
the feature natively.</p>
<p>Using unnecessary polyfills creates several problems:</p>
<ul>
  <li> <strong>Increased bundle size</strong>: Polyfills add extra code to your application, making it larger and slower to download </li>
  <li> <strong>Performance overhead</strong>: Polyfill implementations are often slower than native browser implementations </li>
  <li> <strong>Maintenance burden</strong>: Extra dependencies require updates and security monitoring </li>
  <li> <strong>Runtime complexity</strong>: Polyfills may behave slightly differently from native implementations </li>
</ul>
<p>Modern build tools and package managers make it easy to accidentally include polyfills even when they’re not needed. This often happens when:</p>
<ul>
  <li> Target environments are updated but polyfill dependencies remain </li>
  <li> Developers copy code from projects with different browser support requirements </li>
  <li> Automatic polyfill injection tools are overly conservative </li>
</ul>
<p>By removing unnecessary polyfills, you can reduce your application’s size, improve performance, and simplify your dependency tree while maintaining
the same functionality.</p>
<h3>What is the potential impact?</h3>
<p>Using unnecessary polyfills increases bundle size and reduces application performance. In large applications, this can significantly impact load
times and user experience, especially on slower networks or devices.</p>
<h3>How to fix?</h3>
<p>Remove the polyfill import and use the native method directly. The native implementation will be available in all your target environments.</p>
<h4>Non-compliant code example</h4>
<pre data-diff-id="1" data-diff-type="noncompliant">
import assign from 'object-assign';

const result = assign({}, obj1, obj2); // Noncompliant
</pre>
<h4>Compliant code example</h4>
<pre data-diff-id="1" data-diff-type="compliant">
// No import needed - Object.assign is natively supported
const result = Object.assign({}, obj1, obj2);
</pre>
<h3>Documentation</h3>
<ul>
  <li> <a href="https://github.com/sindresorhus/eslint-plugin-unicorn#readme">eslint-plugin-unicorn</a> - Rule <a
  href="https://github.com/sindresorhus/eslint-plugin-unicorn/blob/HEAD/docs/rules/no-unnecessary-polyfills.md">no-unnecessary-polyfills</a> </li>
  <li> core-js-compat - <a href="https://github.com/zloirock/core-js/tree/HEAD/packages/core-js-compat">Tool for checking JavaScript feature
  compatibility across different environments</a> </li>
  <li> Browserslist - <a href="https://browsersl.ist/">Tool for specifying target browser versions for your project</a> </li>
  <li> MDN Web Docs - Polyfill - <a href="https://developer.mozilla.org/en-US/docs/Glossary/Polyfill">Explanation of what polyfills are and when to
  use them</a> </li>
</ul>

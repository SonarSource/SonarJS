<p>This rule raises an issue when global functions like <code>parseInt()</code>, <code>parseFloat()</code>, <code>isNaN()</code>,
<code>isFinite()</code> or global values like <code>NaN</code>, <code>Infinity</code> are used instead of their <code>Number</code> constructor
equivalents.</p>
<h2>Why is this an issue?</h2>
<p>ECMAScript 2015 introduced static methods and properties on the <code>Number</code> constructor to replace several global functions and values.
Using these <code>Number</code> equivalents provides several benefits:</p>
<p><strong>Consistency and Organization</strong>: All number-related utilities are grouped under the <code>Number</code> namespace, making the code
more organized and easier to understand.</p>
<p><strong>Reduced Global Namespace Pollution</strong>: By using <code>Number</code> methods instead of globals, you help keep the global namespace
cleaner and reduce the risk of naming conflicts.</p>
<p><strong>Improved Behavior</strong>: Some <code>Number</code> methods have better behavior than their global counterparts:</p>
<ul>
  <li> <code>Number.isNaN()</code> only returns <code>true</code> for actual <code>NaN</code> values, while global <code>isNaN()</code> coerces
  non-numbers to numbers first, leading to unexpected results </li>
  <li> <code>Number.isFinite()</code> only returns <code>true</code> for finite numbers, while global <code>isFinite()</code> coerces non-numbers
  first </li>
</ul>
<p><strong>Modern JavaScript Standards</strong>: Using <code>Number</code> methods aligns with modern JavaScript practices and demonstrates
familiarity with ES2015+ features.</p>
<p>The global functions still exist for backward compatibility, but the <code>Number</code> equivalents are the recommended approach in modern
JavaScript development.</p>
<h3>What is the potential impact?</h3>
<p>Using global functions instead of <code>Number</code> methods can lead to:</p>
<ul>
  <li> <strong>Unexpected behavior</strong>: Global <code>isNaN()</code> and <code>isFinite()</code> perform type coercion, which can cause bugs when
  checking non-number values </li>
  <li> <strong>Code inconsistency</strong>: Mixing global and <code>Number</code> methods makes the codebase less uniform </li>
  <li> <strong>Maintainability issues</strong>: Code that doesnâ€™t follow modern standards may be harder for other developers to understand and
  maintain </li>
</ul>
<h3>How to fix?</h3>
<p>Replace global parsing functions with their Number equivalents. The behavior is identical, but the Number methods are more explicit and
organized.</p>
<h4>Non-compliant code example</h4>
<pre data-diff-id="1" data-diff-type="noncompliant">
const num1 = parseInt('42', 10); // Noncompliant
const num2 = parseFloat('3.14'); // Noncompliant
</pre>
<h4>Compliant code example</h4>
<pre data-diff-id="1" data-diff-type="compliant">
const num1 = Number.parseInt('42', 10);
const num2 = Number.parseFloat('3.14');
</pre>
<h3>Documentation</h3>
<ul>
  <li> Number.parseInt() - MDN - <a
  href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/parseInt">Documentation for Number.parseInt()
  method</a> </li>
  <li> Number.parseFloat() - MDN - <a
  href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/parseFloat">Documentation for Number.parseFloat()
  method</a> </li>
  <li> Number.isNaN() - MDN - <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/isNaN">Documentation
  for Number.isNaN() method and its differences from global isNaN()</a> </li>
  <li> Number.isFinite() - MDN - <a
  href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/isFinite">Documentation for Number.isFinite() method
  and its differences from global isFinite()</a> </li>
</ul>
